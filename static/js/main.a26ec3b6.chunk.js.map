{"version":3,"sources":["game/init.js","index.js"],"names":["config","splitTex","tex","rows","cols","regions","sizeX","width","sizeY","height","y","x","push","TextureRegion","init","gl","canvas","a","async","drawWidth","worldWidth","worldHeight","loadTexture","bg","whiteTex","createWhiteTex","puzzle","cells","offsetX","offsetY","size","margin","pad","displayPositions","i","Math","floor","states","finish","switchState","toSwitch","undefined","step","move","random","result","randomize","camera","createOrthoCamera","batch","createBatch","inputHandler","InputHandler","screenClickPos","worldClickPos","animating","handleInput","animateX","animateY","addEventListener","devicePixelRatio","unprojectVector2","clickX","clickY","length","displayPos","running","stop","cleanup","finishGame","onFinish","scale","processEffect","delta","min","TRANSITION_SPEED","abs","clearColor","render","clear","COLOR_BUFFER_BIT","setProjection","combined","begin","draw","state","cell","posX","posY","drawSize","setColor","end","accumulate","lastUpdate","Date","now","loop","requestAnimationFrame","setOnFinish","handler","document","getElementById","window","displayWidth","clientWidth","displayHeight","clientHeight","resize","game","getContext","antialias","startNewGame","setTimeout"],"mappings":"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","file":"static/js/main.a26ec3b6.chunk.js","sourcesContent":["import createOrthoCamera from \"gdxjs/lib/orthoCamera\";\nimport createBatch from \"gdxjs/lib/createBatch\";\nimport InputHandler from \"gdxjs/lib/InputHandler\";\nimport loadTexture from \"gdxjs/lib/loadTexture\";\n\nimport createWhiteTex from \"gl-white-texture\";\nimport TextureRegion from \"gdxjs/lib/TextureRegion\";\n\nconst config = {\n  bg: \"./starry-bg.jpg\",\n  puzzle: \"./starry-unicorn.jpg\",\n  clearColor: [60 / 255, 67 / 255, 171 / 255]\n};\n\n// const config = {\n//   bg: \"./dating-bg.jpg\",\n//   puzzle: \"./tingme.jpg\",\n//   clearColor: [1, 0.7, 0.7]\n// };\n\nconst splitTex = (tex, rows, cols) => {\n  const regions = [];\n  const sizeX = tex.width / cols;\n  const sizeY = tex.height / rows;\n\n  for (let y = 0; y < rows; y++) {\n    for (let x = 0; x < cols; x++) {\n      regions.push(new TextureRegion(tex, x * sizeX, y * sizeY, sizeX, sizeY));\n    }\n  }\n  return regions;\n};\n\nconst init = async (gl, width, height, canvas) => {\n  const targetRatio = 812 / 375;\n  let worldWidth, worldHeight, drawWidth;\n\n  if (width <= height / targetRatio) {\n    worldWidth = 300;\n    drawWidth = worldWidth;\n    worldHeight = (worldWidth / width) * height;\n  } else {\n    worldHeight = 300 * targetRatio;\n    drawWidth = worldHeight / targetRatio;\n    worldWidth = (worldHeight / height) * width;\n  }\n\n  const bg = await loadTexture(gl, config.bg);\n  const whiteTex = createWhiteTex(gl);\n  const puzzle = await loadTexture(gl, config.puzzle);\n\n  const cells = splitTex(puzzle, 3, 3);\n  // cells[0] = false;\n\n  const pad = 5;\n  const margin = drawWidth * 0.05;\n  const size = (drawWidth - margin * 2 - pad * 2) / 3;\n\n  const offsetX = (worldWidth - drawWidth) / 2;\n  const offsetY = (worldHeight - size * 3 - pad * 2) / 2;\n\n  const displayPositions = [];\n  for (let i = 0; i < 9; i++) {\n    const x = i % 3;\n    const y = Math.floor(i / 3);\n    displayPositions.push({\n      x: offsetX + margin + x * (size + pad),\n      y: offsetY + y * (size + pad),\n      width: size,\n      height: size\n    });\n  }\n\n  const states = [null];\n  let finish = false;\n\n  for (let i = 1; i < 9; i++) {\n    states.push(i);\n  }\n\n  const switchState = i => {\n    let toSwitch;\n    if (finish) {\n      return;\n    }\n    if (i - 3 >= 0 && !states[i - 3]) {\n      toSwitch = i - 3;\n    } else if (i + 3 < 9 && !states[i + 3]) {\n      toSwitch = i + 3;\n    } else if (i % 3 > 0 && !states[i - 1]) {\n      toSwitch = i - 1;\n    } else if (i % 3 < 2 && !states[i + 1]) {\n      toSwitch = i + 1;\n    }\n    if (toSwitch !== undefined) {\n      states[toSwitch] = states[i];\n      states[i] = null;\n    }\n    return toSwitch;\n  };\n\n  const randomize = (step = 10) => {\n    let move = 0;\n    while (move < step) {\n      const i = Math.floor(Math.random() * 9);\n      const result = switchState(i);\n      if (result !== undefined) {\n        move++;\n      }\n    }\n  };\n\n  randomize(100);\n\n  const camera = createOrthoCamera(worldWidth, worldHeight, width, height);\n  const batch = createBatch(gl);\n  const inputHandler = new InputHandler(canvas);\n\n  const screenClickPos = [];\n  const worldClickPos = [];\n\n  let animating = -1;\n  let animateX, animateY;\n\n  const handleInput = i => {\n    const result = switchState(i);\n    if (result !== undefined) {\n      animating = result;\n      if (animating - i === 3) {\n        animateX = 0;\n        animateY = -(size + pad);\n      } else if (animating === i - 3) {\n        animateX = 0;\n        animateY = size + pad;\n      } else if (animating - i === 1) {\n        animateY = 0;\n        animateX = -(size + pad);\n      } else if (animating === i - 1) {\n        animateY = 0;\n        animateX = size + pad;\n      }\n    }\n  };\n\n  inputHandler.addEventListener(\"touchStart\", (x, y) => {\n    screenClickPos[0] = x * devicePixelRatio;\n    screenClickPos[1] = y * devicePixelRatio;\n    camera.unprojectVector2(worldClickPos, screenClickPos);\n\n    const clickX = worldClickPos[0];\n    const clickY = worldClickPos[1];\n\n    for (let i = 0; i < displayPositions.length; i++) {\n      const displayPos = displayPositions[i];\n      if (\n        clickX >= displayPos.x &&\n        clickX <= displayPos.x + displayPos.width &&\n        clickY >= displayPos.y &&\n        clickY <= displayPos.y + displayPos.height\n      ) {\n        handleInput(i);\n        break;\n      }\n    }\n  });\n\n  let running = true;\n  let onFinish;\n\n  const stop = () => {\n    running = false;\n    inputHandler.cleanup();\n  };\n\n  const finishGame = () => {\n    onFinish && onFinish();\n  };\n\n  const TRANSITION_SPEED = 5 / 0.2;\n  const THRESHOLD = 0.1;\n  let scale = 0;\n\n  const processEffect = delta => {\n    if (finish) {\n      scale = Math.min(scale + (TRANSITION_SPEED / 10) * delta, 1);\n    }\n\n    if (Math.abs(animateX - 0) < THRESHOLD) {\n      animateX = 0;\n    }\n    if (Math.abs(animateY - 0) < THRESHOLD) {\n      animateY = 0;\n    }\n    if (animateX !== 0) {\n      animateX += (0 - animateX) * TRANSITION_SPEED * delta;\n    }\n    if (animateY !== 0) {\n      animateY += (0 - animateY) * TRANSITION_SPEED * delta;\n    }\n    if (animateX === 0 && animateY === 0) {\n      animating = false;\n    }\n  };\n\n  gl.clearColor(\n    config.clearColor[0],\n    config.clearColor[1],\n    config.clearColor[2],\n    1\n  );\n\n  const render = () => {\n    gl.clear(gl.COLOR_BUFFER_BIT);\n\n    batch.setProjection(camera.combined);\n    batch.begin();\n\n    batch.draw(bg, offsetX, 0, drawWidth, worldHeight);\n    for (let i = 0; i < 9; i++) {\n      let state = states[i];\n      if (!state) {\n        if (!finish) {\n          continue;\n        } else {\n          state = 0;\n        }\n      }\n      const cell = cells[state];\n      const displayPos = displayPositions[i];\n      let posX = displayPos.x;\n      let posY = displayPos.y;\n      let drawSize = size;\n\n      if (finish) {\n        drawSize = size + pad * scale;\n      }\n\n      if (animating === i) {\n        posX = posX + animateX;\n        posY = posY + animateY;\n      }\n\n      batch.setColor(0, 0, 0, 0.5);\n      batch.draw(whiteTex, posX + 3, posY + 3, drawSize, drawSize);\n      batch.setColor(1, 1, 1, 1);\n      cell.draw(batch, posX, posY, drawSize, drawSize);\n    }\n\n    batch.end();\n\n    if (!finish) {\n      finish = true;\n      for (let i = 1; i < 9; i++) {\n        if (states[i] !== i) {\n          finish = false;\n          break;\n        }\n      }\n      if (finish) {\n        finishGame();\n      }\n    }\n  };\n\n  let STEP = 0.016;\n  let accumulate = 0;\n  let lastUpdate = Date.now();\n  const loop = () => {\n    const delta = (Date.now() - lastUpdate) / 1000;\n    accumulate += delta;\n    if (accumulate >= STEP) {\n      while (accumulate >= STEP) {\n        processEffect(STEP);\n        accumulate -= STEP;\n      }\n      render();\n    }\n    lastUpdate = Date.now();\n\n    if (running) {\n      requestAnimationFrame(loop);\n    }\n  };\n\n  loop();\n\n  return {\n    stop,\n    setOnFinish: handler => (onFinish = handler)\n  };\n};\n\nexport default init;\n","import \"./index.css\";\nimport init from \"./game/init\";\n\nfunction resize(canvas) {\n  const devicePixelRatio = window.devicePixelRatio || 1;\n\n  const displayWidth = canvas.clientWidth * devicePixelRatio;\n  const displayHeight = canvas.clientHeight * devicePixelRatio;\n\n  if (canvas.width !== displayWidth || canvas.height !== displayHeight) {\n    canvas.width = displayWidth;\n    canvas.height = displayHeight;\n  }\n}\n\nconst canvas = document.getElementById(\"mainCanvas\");\nresize(canvas);\n\nconst gl = canvas.getContext(\"webgl\", { antialias: true });\nlet game;\nconst startNewGame = async () => {\n  if (game) {\n    game.stop();\n  }\n  game = await init(gl, canvas.width, canvas.height, canvas);\n  game.setOnFinish(() => setTimeout(startNewGame, 3000));\n};\n\nstartNewGame();\n"],"sourceRoot":""}